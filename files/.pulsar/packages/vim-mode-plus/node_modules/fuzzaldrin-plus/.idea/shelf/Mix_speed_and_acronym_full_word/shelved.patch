Index: src/filter.coffee
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/filter.coffee	(revision 8b31dc86c1ea9c522e3a59b673fac93043c85435)
+++ src/filter.coffee	(revision )
@@ -9,8 +9,8 @@
   scoredCandidates = []
   spotLeft = if maxInners? and maxInners > 0 then maxInners else candidates.length
 
-  allowErrors ?= false
-  isPath ?= true
+  bAllowErrors = if allowErrors? then !!allowErrors else false
+  bIsPath = if isPath? then !!isPath else true
 
   bKey = key?
   prepQuery = scorer.prepQuery(query, optCharRegEx)
@@ -19,7 +19,7 @@
     for candidate in candidates
       string = if bKey then candidate[key] else candidate
       continue unless string
-      score = scorer.score(string, query, prepQuery, allowErrors, isPath)
+      score = scorer.score(string, query, prepQuery, bAllowErrors, bIsPath)
       if score > 0
         scoredCandidates.push({candidate, score})
         break unless --spotLeft
Index: src/scorer.coffee
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/scorer.coffee	(revision 8b31dc86c1ea9c522e3a59b673fac93043c85435)
+++ src/scorer.coffee	(revision )
@@ -245,7 +245,16 @@
   return isSeparator(curr_s) or isSeparator(prev_s) or # match IS or FOLLOW a separator
       (  curr_s isnt subject_lw[pos] and prev_s is subject_lw[pos - 1] ) # match is Capital in camelCase (preceded by lowercase)
 
+#Like isWordStart but exclude separator.
+isWordStartStrict = (pos, subject, subject_lw) ->
+  return true if pos is 0 # match is FIRST char ( place a virtual token separator before first char of string)
+  curr_s = subject[pos]
+  prev_s = subject[pos - 1]
+  return isSeparator(prev_s) or #  FOLLOW a separator
+      (  curr_s isnt subject_lw[pos] and prev_s is subject_lw[pos - 1] ) # match is Capital in camelCase (preceded by lowercase)
 
+
+
 exports.isWordEnd = isWordEnd = (pos, subject, subject_lw, len) ->
   return true if  pos is len - 1 # last char of string
   curr_s = subject[pos]
@@ -433,10 +442,26 @@
   if(count < 2)
     return emptyAcronymResult
 
-  #Acronym are scored as start of word, but not full word
-  score = scorePattern(count, n, sameCase, true, false) # wordStart = true, wordEnd = false
 
+  # Acronym are scored as start of word
+  # If the acronym is a 1:1 match with candidate acronym then it is upgraded to fullword.
+  fullWord if count is n then isAcronymFullWord(subject, query) else false
+  score = scorePattern(count, n, sameCase, true, fullWord)
+
   return new AcronymResult(score, pos / count, count)
+
+
+isAcronymFullWord = (subject, query) ->
+  m = subject.length
+  n = query.length
+  count++
+
+  #for each char of subject
+  i = -1
+  while ++i < m
+    if isWordStartStrict(i, subject, subject_lw) and ++count > n then return false
+
+  return true
 
 
 #----------------------------------------------------------------------
\ No newline at end of file
